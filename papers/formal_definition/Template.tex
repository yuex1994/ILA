%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 11 pt]{article}
\usepackage[utf8]{inputenc}     

\usepackage{url}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{proof}
\usepackage{tikz}
\usepackage[margin=1.2in]{geometry}

\title{Instruction-Level Abstraction Synthesis Template Definition}
\author{
    \begin{tabular}{ccccc}
    Hongce~Zhang & Pramod~Subramanyan & Bo-Yuan~Huang & Aarti~Gupta$^\dagger$ & Sharad~Malik \\
    \multicolumn{5}{c} {Departments of Computer Science$^\dagger$ and Electrical Engineering, Princeton University} \\
    \end{tabular}
}
\date{Draft Working Document: \today}

\usepackage{natbib}
\usepackage{graphicx}

\begin{document}

\providecommand{\bd}[0]{\mathbb{B}}
\providecommand{\st}[1]{\mathrm{#1}}
\providecommand{\ft}[1]{\mathtt{#1}}

\maketitle

\section{Template for Instructions}
Template provides human insights for abstraction. 

%arch states
A template should specify module input $W$ and the architectural states $S$ including both registers and memories. These states should be visible from the outside the module interface. The visibility here can be direct, meaning its value is accessible from the outside, or indirect. In the latter case, some directly visible states are updated according to the value of indirect ones. 

Fetch function $F$ inside the template specifies what an abstract instruction is made of. It is a function that maps states and inputs to a bitvector (or the instruction). The fetch valid function $V$ gives the condition when there is truly an instruction for the module. It is designed to help model accelerators which do not always have an instruction to execute.

Each type of instruction is associated with a decode function. This function gives a 1 if the bitvector generated by fetching is the type of instruction it represents. The set of decode functions describes the instruction set.

Unlike ILA, the template does not have a set of state update functions, but a unified one with ``holes'' or unknown parameters in it. The template state update function maps the current sets of states and inputs to the set of future values.
 
The template is defined as, 

\begin{eqnarray}
  \mathrm{T} &=& \langle S, W, F, V, D, P, T\rangle \text{, where} \nonumber \\
      &S& \text{ is the set of state variables, } \nonumber \\
      &W& \text{ is the set of input variables, } \nonumber \\
      &V& :(S\times W) \mapsto \bd \text{ is the valid function, } \nonumber \\
      &F& :(S\times W) \mapsto bvec_w \text{ is the fetch function,} \nonumber \\
      &D& = \{ \delta_i : bvec_w \mapsto \bd \} 
            \text{ is the set of decode functions,} \nonumber \\
      &P& = \{ p_j \} \text{ is the set of parameters, } \nonumber \\
            & &\text{whose values depends solely on the assignment of $D$, and } \nonumber \\
      &N& = (S \times W \times P) \mapsto S 
            \text{ is the template of next state functions.} \nonumber
\end{eqnarray}

%
      %&U& = \{ f_k : (bvec\times bvec\times ...) \mapsto bvec \} \text{ is the set of uninterpreted functions, and} \nonumber \\

The parameters $\{ p_j \}$ here are the ``holes'' we allow in the our template. They appear in the form of unknown constants within a range, undetermined choices, slicing certain bits from a bitvector and so on. The value of these parameters should be determined once an assignment to the set decode functions ($D$) is given. In other word, the unknown constants, the choices, and etc. should be fixed for a given kind of instructions.

\section{Template for Child-Instructions}

Because we are synthesizing child-instructions from the implementation that has the same micro-architecture, we assume that the simulator is capable of isolate the behavior of exact the child-instructions. Because at the synthesis time, not all the state update functions are known, the solver may not have enough information to compute the exact condition for isolating the child-instructions' update. The current workaround is to manipulate the refinement relation to set the microarchitectural states such that the other instructions or child instructions are not triggered.

The template for child-instructions is defined similarly, except that they don't have direct access to inputs. The template is defined as follows,

\begin{eqnarray}
  \mathrm{T} &=& \langle S^{\mu}, F^{\mu}, V^{\mu}, D^{\mu}, P^{\mu}, T^{\mu}\rangle \text{, where} \nonumber \\
      &S^{\mu}& \text{ is the set of state variables, } \nonumber \\
      &V^{\mu}& :S^{\mu} \mapsto \bd \text{ is the valid function, } \nonumber \\
      &F^{\mu}& :S^{\mu} \mapsto bvec_w \text{ is the fetch function,} \nonumber \\
      &D^{\mu}& = \{ \delta_i : bvec_w \mapsto \bd \} 
            \text{ is the set of decode functions,} \nonumber \\
      &P^{\mu}& = \{ p_j^{\mu} \} \text{ is the set of parameters, } \nonumber \\
            & &\text{whose values depends solely on the assignment of $D^{\mu}$, and } \nonumber \\
      &N^{\mu}& = (S^{\mu} \times W^{\mu} \times P^{\mu}) \mapsto S^{\mu} 
            \text{ is the template of next state functions.} \nonumber
\end{eqnarray}

In the above definition, the set of variables of child-instructions are a super set of the architecture states, namely $S \subset S^{\mu}$. 


%\bibliographystyle{plain}
%\bibliography{references}
\end{document}

